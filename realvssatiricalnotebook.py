# -*- coding: utf-8 -*-
"""realVsSatiricalNotebook.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J0HV7_kAa5cCv5yE-3hDvtVObCl5o6Bu

###Data Acquisition
Data was acquired by ***Web Scrapping***. We used various sources for each label.
Data was added and collected regularly to the dataset until the number of articles reached approximately 500 for each label.
"""

# importing libraries necessary to scrape data
import requests
from bs4 import BeautifulSoup
import pandas as pd

# for extracting links from homepage of source
def real():
    url = ""
    page_request = requests.get(url)
    data = page_request.content
    soup = BeautifulSoup(data,"html.parser")

    for divtag in soup.find_all('div', {'class': 'headlines-list'}):
        for ultag in divtag.find_all('ul', {'class': 'clearfix'}):
            for litag in ultag.find_all('li'):
                print("" + litag.find('a')['href'])
                #print(str(counter) + "." + litag.text + " -" + litag.find('a')['href'])

    for divtag in soup.find_all('div', {'class': 'top-newslist small'}):
        for ultag in divtag.find_all('ul', {'class': 'cvs_wdt clearfix'}):
            for litag in ultag.find_all('li'):
                print("" + litag.find('a')['href'])

    for divtag in soup.find_all('div', {'class': 'news_card'}):
        for ultag in divtag.find_all('ul', {'class': 'cvs_wdt clearfix'}):
            for litag in ultag.find_all('li'):
                print("" + litag.find('a')['href'])

real()

dataRH = []  # to store headings
dataRP = []  # to store paragraphs or text

def extractDataR(url):
  global dataRH, dataRP # declaring global variables
  response = requests.get(url)
  #print(response)
  htmlContent = response.content
  soup = BeautifulSoup(htmlContent, 'html.parser')
  headLine = soup.find_all('title')
  #print("Number of headlines found:", len(headLine))
  for head in headLine:
    text = head.text.strip()
    dataRH.append({'Text': text})
    #print(text)
  pTags = soup.find_all('div', class_ ="_s30J clearfix")
  for p in pTags:
    pText = p.text.strip()
    dataRP.append({'Text': pText})
    #print(pText)
  p1Tags = soup.find_all('div', class_ ="mgid_second_mrec_parent")
  for p1 in p1Tags:
    p1Text = p1.text.strip()
    dataRP.append({'Text': p1Text})
    #print(p1Text)
  dfRH = pd.DataFrame(dataRH)
  #print("Number of headlines in dfH:", len(dfRH))
  #print(dfRH)
  dfRH.to_csv('dataH.csv',index=False)
  dfRP = pd.DataFrame(dataRP)
  #print(dfRP)
  dfRP.to_csv('dataP.csv',index=False)

linkR = []  # stores links

for i in range(0,len(linkR)):
    extractDataR(linkR[i])

print("success")

dataFH = []
dataFP = []

def extractDataF(url):
  global dataFH, dataFP # declaring global variables
  response = requests.get(url)
  #print(response)
  htmlContent = response.content
  soup = BeautifulSoup(htmlContent, 'html.parser')
  headLine = soup.find_all('h1')
  #print("Number of headlines found:", len(headLine))
  for head in headLine:
    text = head.text.strip()
    dataFH.append({'Text': text})
    #print(text)
  pTags = soup.find_all('p')
  for p in pTags:
    pText = p.text.strip()
    dataFP.append({'Text': pText})
    #print(pText)
  dfFH = pd.DataFrame(dataFH)
  #print("Number of headlines in dfH:", len(dfFH))
  #print(dfFH)
  dfFH.to_csv('dataFH.csv',index=False)
  dfFP = pd.DataFrame(dataFP)
  #print(dfFP)
  dfFP.to_csv('dataFP.csv',index=False)

url = ['']

def satirical(url):
    data = []
    page_request = requests.get(url)
    data = page_request.content
    soup = BeautifulSoup(data,"html.parser")

    for article in soup.find_all('article'):
      print(article.find('a')['href'])

for i in range(len(url)):
  satirical(url[i])

linkF = []

for i in range(len(linkF)):
  extractDataF(linkF[i])

print("success")

"""###Preprocessing
1) ***Data Cleaning*** involves the process of identifying and correcting errors or inconsistencies in the dataset.

2) ***Text Lowercasing*** refers to the process of converting all characters in the text to lowercase.

3) ***Tokenization*** is the process of breaking down a text into smaller units, usually words or phrases.

4) ***Stop Word Removal*** is the process of filtering out common words before or after processing of natural language data.

5) ***Lemmatization*** is the process of reducing words to their base or dictionary form.

6) ***Text Normalization*** involves transforming text into a standard format, ensuring uniformity and consistency in the text data.
"""

dfT = pd.read_excel('/content/TrueDataset.xlsx')
dfT.head()

dfF = pd.read_excel('/content/FakeNewsDataset.xlsx')

# Concatenating fake and real dataset
df = pd.concat([dfT,dfF])
df.tail()

df.drop(['Ind. No'], axis = 1, inplace = True)

# Shuffling the dataframe
df = df.sample(frac = 1)
df.head()

df['Combined'] = df['Headings'] + ' ' + df['Text']

combined = df['Combined'].str.lower()

headings = df['Headings'].str.lower()

text = df['Text'].str.lower()

""" Removing punctuations"""

import re

def remove_pun(text):
  return re.sub(r'[!"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~]', '', text)

headings = headings.apply(remove_pun)

text = text.apply(remove_pun)

combined = combined.apply(remove_pun)

"""Removing special characters"""

import unicodedata

def remove_special_characters(text):
    # Remove non-ASCII characters
    text = unicodedata.normalize('NFKD', text).encode('ascii', 'ignore').decode('utf-8', 'ignore')
    # Remove remaining special characters
    text = re.sub(r'[^\w\s]', '', text)
    return text

headings = headings.apply(remove_special_characters)

text = text.apply(remove_special_characters)

combined = combined.apply(remove_special_characters)

"""Tokenization"""

import nltk
from nltk.corpus import stopwords
from nltk.tokenize import word_tokenize

nltk.download('stopwords')
nltk.download('punkt')

words_headings = []

for items1 in headings:
  # Tokenize the text
  tokens1 = word_tokenize(items1)
  words_headings.append(tokens1)

words_text = []

for items2 in text:
  # Tokenize the text
  tokens2 = word_tokenize(items2)
  words_text.append(tokens2)

words_combined = []

for items3 in combined:
  # Tokenize the text
  tokens3 = word_tokenize(items3)
  words_combined.append(tokens3)

"""Stop Word Removal"""

stop_words = set(stopwords.words('english'))

filtered_words_headings = []
for tokens1 in words_headings:
    filtered_tokens1 = [word for word in tokens1 if word.lower() not in stop_words]
    filtered_words_headings.append(filtered_tokens1)

filtered_words_text = []

for tokens2 in words_text:
  filtered_tokens2 = [word for word in tokens2 if word.lower() not in stop_words]
  filtered_words_text.append(filtered_tokens2)

filtered_words_combined = []

for tokens3 in words_combined:
  filtered_tokens3 = [word for word in tokens3 if word.lower() not in stop_words]
  filtered_words_combined.append(filtered_tokens3)

"""Lemmatization"""

from nltk.stem import WordNetLemmatizer
lemmatizer = WordNetLemmatizer()

nltk.download('wordnet')

lemmatized_words_headings = [[lemmatizer.lemmatize(word) for word in tokens]
                              for tokens in filtered_words_headings]

lemmatized_words_text = [[lemmatizer.lemmatize(word) for word in tokens]
                          for tokens in filtered_words_text]

lemmatized_words_combined = [[lemmatizer.lemmatize(word) for word in tokens]
                              for tokens in filtered_words_combined]

"""Text Normalization"""

def text_normalization(tokens):
    normalized_tokens = []
    for word in tokens:
        if 'exmple' in word:
            normalized_tokens.append(re.sub(r'exmple', 'example', word))
        else:
            normalized_tokens.append(word)
    return normalized_tokens

normalized_words_headings = [[text_normalization(tokens)]
                              for tokens in lemmatized_words_headings]

normalized_words_text = [[text_normalization(tokens)]
                        for tokens in lemmatized_words_text]

normalized_words_combined = [[text_normalization(tokens)]
                        for tokens in lemmatized_words_combined]

"""###Exploratory Data Analysis
We had limited options for ***EDA*** as it is difficult to generate graphs from text data. Therefore, we have considered only four techniques.

1) ***Word Length Analysis***  involves examining the lengths of words in a text or a corpus.

2) ***Word Frequency Analysis*** involves counting the occurrences of each word and helps in understanding the most common and least common words used in the text.

3) ***Bi-Grams*** are pairs of consecutive words that occur in a sequence within a text.

4) ***Word Clouds*** are visual representations of text data where the size of each word is proportional to its frequency in the text.
"""

import pandas as pd
from nltk import ngrams
from collections import Counter
import seaborn as sns
import matplotlib.pyplot as plt
from wordcloud import WordCloud
from gensim import corpora
from gensim.models import LdaModel

df_False = pd.read_csv("/content/StopWordFalse (2).csv")
df_False

df_True = pd.read_csv("/content/StopWordTrue (2).csv")
df_True

def generate_ngrams(text, n):
    words = text.split()
    output = list(ngrams(words, n))
    return output

n_grams1_result = []
for index, row in df_False.iterrows():
    text = row["Headings"] + " " + row["Text"]
    n_grams1 = generate_ngrams(text, 2)
    n_grams1_result.extend(n_grams1)

n_grams2_result = []
for index, row in df_True.iterrows():
    text = row["Headings"] + " " + row["Text"]
    n_grams2 = generate_ngrams(text, 2)
    n_grams2_result.extend(n_grams2)

n_grams_counts1 = Counter(n_grams1_result)
#print(n_grams_counts)
l1 = list(n_grams_counts1.items())

n_grams_counts2 = Counter(n_grams2_result)
#print(n_grams_counts)
l2 = list(n_grams_counts2.items())

dfN1 = pd.DataFrame(l1, columns=['Ngrams', 'Count'])
dfN1 = dfN1.sort_values('Count', ascending=False)
dfN1.head(15)

dfN2 = pd.DataFrame(l2, columns=['Ngrams', 'Count'])
dfN2 = dfN2.sort_values('Count', ascending=False)
dfN2.head(15)

DF_fake = pd.read_excel('/content/normalisedFake.xlsx')

DF_true = pd.read_excel('/content/normalisedTrue.xlsx')

# word frequency
all_text = ' '.join(DF_fake.apply(lambda row: ' '.join(row.astype(str)), axis=1).tolist())
words = all_text.lower().split()
word_freq = Counter(words)
df_word_freq = pd.DataFrame(word_freq.most_common(), columns=['Word', 'Frequency'])
df_word_freq

# word frequency
all_text1 = ' '.join(DF_true.apply(lambda row: ' '.join(row.astype(str)), axis=1).tolist())
words1 = all_text1.lower().split()
word_freq1 = Counter(words1)
df_word_freq1 = pd.DataFrame(word_freq1.most_common(), columns=['Word', 'Frequency'])
df_word_freq1

plt.figure(dpi=1000)
sns.barplot(x='Frequency', y='Word', data=df_word_freq.head(20), palette='Oranges')
plt.title('Word Frequency Analysis for Satirical News')
plt.xlabel('Frequency')
plt.ylabel('Word')
plt.show()

plt.figure(dpi=1000)
sns.barplot(x='Frequency', y='Word', data=df_word_freq1.head(20), palette='Oranges')
plt.title('Word Frequency Analysis for True News')
plt.xlabel('Frequency')
plt.ylabel('Word')
plt.show()

docLen = [len(d) for d in DF_fake.Text]
df_docLen = pd.DataFrame({'Doc_Length': docLen})
plt.figure(dpi=100)
sns.histplot(x='Doc_Length', data=df_docLen, bins=200, palette='Oranges')
plt.title('Word Length Analysis for Satirical News')
plt.xlabel('Frequency')
plt.ylabel('Word')
plt.show()

docLen1 = [len(d) for d in DF_true.Text]
df_docLen1 = pd.DataFrame({'Doc_Length': docLen1})
plt.figure(dpi=100)
sns.histplot(x='Doc_Length', data=df_docLen1, bins=200, palette='Oranges')
plt.title('Word Length Analysis for True News')
plt.xlabel('Frequency')
plt.ylabel('Word')
plt.show()

# word cloud
word_dict = dict(zip(df_word_freq['Word'], df_word_freq['Frequency']))
wordcloud = WordCloud(width=800, height=800, background_color='grey', colormap='Oranges').generate_from_frequencies(word_dict)

plt.figure(dpi=1000, facecolor=None)
plt.imshow(wordcloud)
plt.axis("off")
plt.tight_layout(pad=0)
plt.show()

# word cloud for true
word_dict1 = dict(zip(df_word_freq1['Word'], df_word_freq1['Frequency']))
wordcloud1 = WordCloud(width=800, height=800, background_color='grey', colormap='Oranges').generate_from_frequencies(word_dict1)

plt.figure(dpi=1000, facecolor=None)
plt.imshow(wordcloud1)
plt.axis("off")
plt.tight_layout(pad=0)
plt.show()

"""###Splitting data
***Flattening*** the data and then ***splitting*** it into training, testing and validation.
"""

import numpy as np

flattened_headings = []
for document in normalized_words_headings:
    flattened_headings.extend([" ".join(tokens) for tokens in document])

X_headings = np.array(flattened_headings)

flattened_text = []
for document in normalized_words_text:
    flattened_text.extend([" ".join(tokens) for tokens in document])

X_text = np.array(flattened_text)

flattened_combined = []
for document in normalized_words_combined:
    flattened_combined.extend([" ".join(tokens) for tokens in document])

X_combined = np.array(flattened_combined)

df['Label'] = df['Label'].astype(str)
from sklearn.preprocessing import LabelEncoder
custom_mapping = {'Fake': 0, 'True': 1}
df['Label'] = df['Label'].map(custom_mapping)

# Convert 'Label' column to a NumPy array
y = np.array(df['Label'])

X_headings_train = X_headings[:600,]
X_headings_val = X_headings[600:850,]
X_headings_test = X_headings[850:,]

y_train1 = y[:600,]
y_val1 = y[600:850,]
y_test1 = y[850:,]

X_text_train = X_text[:600,]
X_text_val = X_text[600:850,]
X_text_test = X_text[850:,]

y_train2 = y[:600,]
y_val2 = y[600:850,]
y_test2 = y[850:,]

X_combined_train = X_combined[:600,]
X_combined_val = X_combined[600:850,]
X_combined_test = X_combined[850:,]

y_train3 = y[:600,]
y_val3 = y[600:850,]
y_test3 = y[850:,]

"""###Vectorization
***Vectorization*** involves converting textual data into numerical vectors. It is a crucial step that enables the application of various mathematical and statistical algorithms to process and analyze text data effectively. We have used ***TF-IDF Vectorizer*** to vectorize our data.
"""

from sklearn.feature_extraction.text import TfidfVectorizer

vectorizer = TfidfVectorizer()
X_headings_train_tfidf = vectorizer.fit_transform(X_headings_train)
X_headings_val_tfidf = vectorizer.transform(X_headings_val)
X_headings_test_tfidf = vectorizer.transform(X_headings_test)

X_text_train_tfidf = vectorizer.fit_transform(X_text_train)
X_text_test_tfidf = vectorizer.transform(X_text_test)
X_text_val_tfidf = vectorizer.transform(X_text_val)

X_combined_train_tfidf = vectorizer.fit_transform(X_combined_train)
X_combined_val_tfidf = vectorizer.transform(X_combined_val)
X_combined_test_tfidf = vectorizer.transform(X_combined_test)

"""###Model Building
We have trained our data on machine learning models like ***KNN*** and ***Naive Bayes*** and then, converted the trained model to a pickle file which is used for model deployment.
"""

from sklearn.metrics import accuracy_score, f1_score, jaccard_score, precision_score, recall_score, roc_curve, roc_auc_score
from sklearn.neighbors import KNeighborsClassifier
from sklearn.naive_bayes import MultinomialNB

"""For headings"""

# Initialize classifiers
knn_classifier_headings = KNeighborsClassifier(n_neighbors=7)
naive_bayes_classifier_headings = MultinomialNB()

# Training the classifiers
knn_classifier_headings.fit(X_headings_train_tfidf, y_train1)
naive_bayes_classifier_headings.fit(X_headings_train_tfidf, y_train1)

# Predict on the test set
knn_predictions_headings = knn_classifier_headings.predict(X_headings_test_tfidf)
naive_bayes_predictions_headings = naive_bayes_classifier_headings.predict(X_headings_test_tfidf)

# accuracy function
def accuracy(model):
  train_accuracy = accuracy_score(y_train1, model.predict(X_headings_train_tfidf))
  test_accuracy = accuracy_score(y_test1, model.predict(X_headings_test_tfidf))
  val_accuracy = accuracy_score(y_val1, model.predict(X_headings_val_tfidf))
  print(f"Training Accuracy: {train_accuracy:.2f}")
  print(f"Testing Accuracy: {test_accuracy:.2f}")
  print(f"Validation Accuracy: {val_accuracy:.2f}")

print("KNN")
accuracy(knn_classifier_headings)
print("NB")
accuracy(naive_bayes_classifier_headings)

import matplotlib.pyplot as plt

knn_train_acc = 0.88
knn_test_acc = 0.80
knn_val_acc = 0.78

nb_train_acc = 1.00
nb_test_acc = 0.85
nb_val_acc = 0.88

# Data for plotting
models = ['KNN', 'Naive Bayes']
train_acc = [knn_train_acc, nb_train_acc]
test_acc = [knn_test_acc, nb_test_acc]
val_acc = [knn_val_acc, nb_val_acc]

# Setting the positions and width for the bars
pos = list(range(len(models)))
width = 0.1

# Plotting the bars
fig, ax = plt.subplots(figsize=(6, 7))
plt.bar(pos, train_acc, width, color='#87ceeb', label='Training Accuracy')
plt.bar([p + width for p in pos], test_acc, width, color='#00b4d8', label='Testing Accuracy')
plt.bar([p + width*2 for p in pos], val_acc, width, color='#2c7da0', label='Validation Accuracy')

# Adding labels, title, and legend
plt.xlabel('Models', fontweight='bold')
plt.ylabel('Accuracy', fontweight='bold')
plt.title('Comparison of Training, Testing, and Validation Accuracy for Headings')
plt.xticks([p + width for p in pos], models)
for i in range(len(pos)):
    plt.text(pos[i] + width / 2, train_acc[i], str(train_acc[i]), ha='right', va='bottom')
    plt.text(pos[i] + 3 * width / 2, test_acc[i], str(test_acc[i]), ha='right', va='bottom')
    plt.text(pos[i] + 5 * width / 2, val_acc[i], str(val_acc[i]), ha='right', va='bottom')
plt.legend(loc = 'upper center')

# Display the plot
plt.show()

# ROC-AUC curve for headings
# probabilities = knn_classifier_headings.predict_proba(X_headings_test_tfidf)[:, 1]
probabilities = naive_bayes_classifier_headings.predict_proba(X_headings_test_tfidf)[:, 1]
fpr, tpr, _ = roc_curve(y_test1, probabilities)
roc_auc = roc_auc_score(y_test1, probabilities)

plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC curve (area = {roc_auc:.2f})')
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
# plt.title('KNN: ROC Curve for Headings Only')
plt.title('NB: ROC Curve for Headings Only')
plt.legend(loc="lower right")
plt.show()

import pickle

with open('tfidfHeading', 'wb') as f:
    pickle.dump(vectorizer, f)

with open('knnHeading', 'wb') as f:
    pickle.dump(knn_classifier_headings, f)

with open('nbHeading', 'wb') as f:
    pickle.dump(naive_bayes_classifier_headings, f)

"""For text"""

# Initialize classifiers
knn_classifier_text = KNeighborsClassifier(n_neighbors=7)
naive_bayes_classifier_text = MultinomialNB()

# Training the classifiers
knn_classifier_text.fit(X_text_train_tfidf, y_train2)
naive_bayes_classifier_text.fit(X_text_train_tfidf, y_train2)

# Predict on the test set
knn_predictions_text = knn_classifier_text.predict(X_text_test_tfidf)
naive_bayes_predictions_text = naive_bayes_classifier_text.predict(X_text_test_tfidf)

# accuracy function
def accuracy(model):
  train_accuracy = accuracy_score(y_train2, model.predict(X_text_train_tfidf))
  test_accuracy = accuracy_score(y_test2, model.predict(X_text_test_tfidf))
  val_accuracy = accuracy_score(y_val2, model.predict(X_text_val_tfidf))
  print(f"Training Accuracy: {train_accuracy:.2f}")
  print(f"Testing Accuracy: {test_accuracy:.2f}")
  print(f"Validation Accuracy: {val_accuracy:.2f}")

print("KNN")
accuracy(knn_classifier_text)
print("NB")
accuracy(naive_bayes_classifier_text)

import matplotlib.pyplot as plt

knn_train_acc = 0.94
knn_test_acc = 0.90
knn_val_acc = 0.88

nb_train_acc = 1.00
nb_test_acc = 0.98
nb_val_acc = 0.95

# Data for plotting
models = ['KNN', 'Naive Bayes']
train_acc = [knn_train_acc, nb_train_acc]
test_acc = [knn_test_acc, nb_test_acc]
val_acc = [knn_val_acc, nb_val_acc]

# Setting the positions and width for the bars
pos = list(range(len(models)))
width = 0.1

# Plotting the bars
fig, ax = plt.subplots(figsize=(6, 7))
plt.bar(pos, train_acc, width, color='#87ceeb', label='Training Accuracy')
plt.bar([p + width for p in pos], test_acc, width, color='#00b4d8', label='Testing Accuracy')
plt.bar([p + width*2 for p in pos], val_acc, width, color='#2c7da0', label='Validation Accuracy')

# Adding labels, title, and legend
plt.xlabel('Models', fontweight='bold')
plt.ylabel('Accuracy', fontweight='bold')
plt.title('Comparison of Training, Testing, and Validation Accuracy for Text')
plt.xticks([p + width for p in pos], models)
for i in range(len(pos)):
    plt.text(pos[i] + width / 2, train_acc[i], str(train_acc[i]), ha='right', va='bottom')
    plt.text(pos[i] + 3 * width / 2, test_acc[i], str(test_acc[i]), ha='right', va='bottom')
    plt.text(pos[i] + 5 * width / 2, val_acc[i], str(val_acc[i]), ha='right', va='bottom')
plt.legend(loc = 'upper center')

# Display the plot
plt.show()

# ROC-AUC curve for text
# probabilities = naive_bayes_classifier_text.predict_proba(X_text_test_tfidf)[:, 1]
probabilities = knn_classifier_text.predict_proba(X_text_test_tfidf)[:, 1]
fpr, tpr, _ = roc_curve(y_test2, probabilities)
roc_auc = roc_auc_score(y_test2, probabilities)

plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC curve (area = {roc_auc:.2f})')
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
# plt.title('NB: ROC Curve for Text Only')
plt.title('KNN: ROC Curve for Text Only')
plt.legend(loc="lower right")
plt.show()

import pickle

with open('tfidfText', 'wb') as f:
    pickle.dump(vectorizer, f)

with open('knnText', 'wb') as f:
    pickle.dump(knn_classifier_text, f)

with open('nbText', 'wb') as f:
    pickle.dump(naive_bayes_classifier_text, f)

"""For combined"""

# Initialize classifiers
knn_classifier_combined = KNeighborsClassifier(n_neighbors=7)
naive_bayes_classifier_combined = MultinomialNB()

# Training the classifiers
knn_classifier_combined.fit(X_combined_train_tfidf, y_train3)
naive_bayes_classifier_combined.fit(X_combined_train_tfidf, y_train3)

# Predict on the test set
knn_predictions_combined = knn_classifier_combined.predict(X_combined_test_tfidf)
naive_bayes_predictions_combined = naive_bayes_classifier_combined.predict(X_combined_test_tfidf)

# accuracy function
def accuracy(model):
  train_accuracy = accuracy_score(y_train3, model.predict(X_combined_train_tfidf))
  test_accuracy = accuracy_score(y_test3, model.predict(X_combined_test_tfidf))
  val_accuracy = accuracy_score(y_val3, model.predict(X_combined_val_tfidf))
  print(f"Training Accuracy: {train_accuracy:.2f}")
  print(f"Testing Accuracy: {test_accuracy:.2f}")
  print(f"Validation Accuracy: {val_accuracy:.2f}")

print("KNN")
accuracy(knn_classifier_combined)
print("NB")
accuracy(naive_bayes_classifier_combined)

import matplotlib.pyplot as plt

knn_train_acc = 0.94
knn_test_acc = 0.87
knn_val_acc = 0.88

nb_train_acc = 1.00
nb_test_acc = 0.94
nb_val_acc = 0.96

# Data for plotting
models = ['KNN', 'Naive Bayes']
train_acc = [knn_train_acc, nb_train_acc]
test_acc = [knn_test_acc, nb_test_acc]
val_acc = [knn_val_acc, nb_val_acc]

# Setting the positions and width for the bars
pos = list(range(len(models)))
width = 0.1

# Plotting the bars
fig, ax = plt.subplots(figsize=(6, 7))
plt.bar(pos, train_acc, width, color='#87ceeb', label='Training Accuracy')
plt.bar([p + width for p in pos], test_acc, width, color='#00b4d8', label='Testing Accuracy')
plt.bar([p + width*2 for p in pos], val_acc, width, color='#2c7da0', label='Validation Accuracy')

# Adding labels, title, and legend
plt.xlabel('Models', fontweight='bold')
plt.ylabel('Accuracy', fontweight='bold')
plt.title('Comparison of Training, Testing, and Validation Accuracy for Combined')
plt.xticks([p + width for p in pos], models)
for i in range(len(pos)):
    plt.text(pos[i] + width / 2, train_acc[i], str(train_acc[i]), ha='right', va='bottom')
    plt.text(pos[i] + 3 * width / 2, test_acc[i], str(test_acc[i]), ha='right', va='bottom')
    plt.text(pos[i] + 5 * width / 2, val_acc[i], str(val_acc[i]), ha='right', va='bottom')
plt.legend(loc = 'upper center')

# Display the plot
plt.show()

# ROC-AUC curve for combined
# probabilities = knn_classifier_combined.predict_proba(X_combined_test_tfidf)[:, 1]
probabilities = naive_bayes_classifier_combined.predict_proba(X_combined_test_tfidf)[:, 1]
fpr, tpr, _ = roc_curve(y_test3, probabilities)
roc_auc = roc_auc_score(y_test3, probabilities)

plt.figure()
plt.plot(fpr, tpr, color='darkorange', lw=2, label=f'ROC curve (area = {roc_auc:.2f})')
plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')
plt.xlim([0.0, 1.0])
plt.ylim([0.0, 1.05])
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
# plt.title('KNN: ROC Curve for Combined Text and Headings')
plt.title('NB: ROC Curve for Combined Text and Headings')
plt.legend(loc="lower right")
plt.show()

import pickle

with open('tfidfCombined', 'wb') as f:
    pickle.dump(vectorizer, f)

with open('knnCombined', 'wb') as f:
    pickle.dump(knn_classifier_combined, f)

with open('nbCombined', 'wb') as f:
    pickle.dump(naive_bayes_classifier_combined, f)

"""###Model Deployment
We have deployed our model using ***Streamlit***.

It can take input as either text of the article, or a screenshot of the article. It also has a choice over whether the user wants to upload the heading of the article, the body of the article, or the entire combined article.
The model runs and gives output as either Satirical News or
Real News.
"""

import streamlit as st
import cv2
import pytesseract as pt
import pickle
import os
from sklearn.feature_extraction.text import TfidfVectorizer

tfidf = TfidfVectorizer()

css = """
<style>
@keyframes move {
    100% {
        transform: translate3d(0, 0, 1px) rotate(360deg);
    }
}

.background {
    position: fixed;
    width: 100vw;
    height: 100vh;
    top: 0;
    left: 0;
    background: #fffce6;
    overflow: hidden;
}

.background span {
    width: 15vmin;
    height: 15vmin;
    border-radius: 15vmin;
    backface-visibility: hidden;
    position: absolute;
    animation: move;
    animation-duration: 25s;
    animation-timing-function: linear;
    animation-iteration-count: infinite;
}

.background span:nth-child(0) {
    color: #e7f0f4;
    top: 56%;
    left: 10%;
    animation-duration: 76s;
    animation-delay: -102s;
    transform-origin: -12vw 6vh;
    box-shadow: -30vmin 0 4.2850209678796904vmin currentColor;
}
.background span:nth-child(1) {
    color: #e7f0f4;
    top: 24%;
    left: 96%;
    animation-duration: 152s;
    animation-delay: -156s;
    transform-origin: 3vw 8vh;
    box-shadow: 30vmin 0 4.001761009505196vmin currentColor;
}
.background span:nth-child(2) {
    color: #aec6cf;
    top: 23%;
    left: 96%;
    animation-duration: 22s;
    animation-delay: -244s;
    transform-origin: -13vw 1vh;
    box-shadow: 30vmin 0 3.874379473160472vmin currentColor;
}
.background span:nth-child(3) {
    color: #e7f0f4;
    top: 99%;
    left: 83%;
    animation-duration: 246s;
    animation-delay: -38s;
    transform-origin: 2vw 13vh;
    box-shadow: 30vmin 0 4.3384802129291105vmin currentColor;
}
.background span:nth-child(4) {
    color: #e7f0f4;
    top: 54%;
    left: 13%;
    animation-duration: 134s;
    animation-delay: -115s;
    transform-origin: -11vw -21vh;
    box-shadow: -30vmin 0 3.9260329587822396vmin currentColor;
}
.background span:nth-child(5) {
    color: #e7f0f4;
    top: 8%;
    left: 73%;
    animation-duration: 216s;
    animation-delay: -200s;
    transform-origin: -19vw -11vh;
    box-shadow: 30vmin 0 3.889693724619526vmin currentColor;
}
.background span:nth-child(6) {
    color: #e7f0f4;
    top: 87%;
    left: 79%;
    animation-duration: 181s;
    animation-delay: -63s;
    transform-origin: -8vw -16vh;
    box-shadow: 30vmin 0 4.198411946293855vmin currentColor;
}
.background span:nth-child(7) {
    color: #e7f0f4;
    top: 99%;
    left: 35%;
    animation-duration: 189s;
    animation-delay: -182s;
    transform-origin: -12vw 11vh;
    box-shadow: 30vmin 0 3.957988827082369vmin currentColor;
}
.background span:nth-child(8) {
    color: #aec6cf;
    top: 9%;
    left: 4%;
    animation-duration: 41s;
    animation-delay: -206s;
    transform-origin: 1vw 7vh;
    box-shadow: -30vmin 0 4.6830992652098695vmin currentColor;
}
.background span:nth-child(9) {
    color: #e7f0f4;
    top: 56%;
    left: 81%;
    animation-duration: 204s;
    animation-delay: -59s;
    transform-origin: -2vw 21vh;
    box-shadow: 30vmin 0 4.362591393251875vmin currentColor;
}
.background span:nth-child(10) {
    color: #e7f0f4;
    top: 51%;
    left: 95%;
    animation-duration: 106s;
    animation-delay: -142s;
    transform-origin: 20vw -10vh;
    box-shadow: -30vmin 0 4.30464603282698vmin currentColor;
}
.background span:nth-child(11) {
    color: #e7f0f4;
    top: 5%;
    left: 56%;
    animation-duration: 158s;
    animation-delay: -39s;
    transform-origin: 13vw -18vh;
    box-shadow: -30vmin 0 4.49764479881048vmin currentColor;
}
.background span:nth-child(12) {
    color: #aec6cf;
    top: 27%;
    left: 82%;
    animation-duration: 121s;
    animation-delay: -144s;
    transform-origin: 1vw -12vh;
    box-shadow: 30vmin 0 4.588205242391293vmin currentColor;
}
.background span:nth-child(13) {
    color: #aec6cf;
    top: 9%;
    left: 85%;
    animation-duration: 107s;
    animation-delay: -121s;
    transform-origin: -17vw -4vh;
    box-shadow: -30vmin 0 3.993678747491651vmin currentColor;
}
.background span:nth-child(14) {
    color: #e7f0f4;
    top: 69%;
    left: 74%;
    animation-duration: 240s;
    animation-delay: -162s;
    transform-origin: 23vw -8vh;
    box-shadow: 30vmin 0 3.7523169104251917vmin currentColor;
}
.background span:nth-child(15) {
    color: #aec6cf;
    top: 97%;
    left: 31%;
    animation-duration: 83s;
    animation-delay: -207s;
    transform-origin: -1vw -21vh;
    box-shadow: -30vmin 0 4.1247653016130785vmin currentColor;
}
.background span:nth-child(16) {
    color: #e7f0f4;
    top: 87%;
    left: 45%;
    animation-duration: 116s;
    animation-delay: -87s;
    transform-origin: -19vw -2vh;
    box-shadow: 30vmin 0 4.635123079514468vmin currentColor;
}
.background span:nth-child(17) {
    color: #aec6cf;
    top: 43%;
    left: 77%;
    animation-duration: 239s;
    animation-delay: -90s;
    transform-origin: -1vw -20vh;
    box-shadow: -30vmin 0 4.715496254559995vmin currentColor;
}
.background span:nth-child(18) {
    color: #aec6cf;
    top: 7%;
    left: 60%;
    animation-duration: 61s;
    animation-delay: -139s;
    transform-origin: 14vw 7vh;
    box-shadow: -30vmin 0 4.02343739770485vmin currentColor;
}
.background span:nth-child(19) {
    color: #aec6cf;
    top: 35%;
    left: 72%;
    animation-duration: 51s;
    animation-delay: -129s;
    transform-origin: -2vw -14vh;
    box-shadow: 30vmin 0 4.2584078024709235vmin currentColor;
}
</style>
"""

html = """
<div class="background">
   <span></span>
   <span></span>
   <span></span>
   <span></span>
   <span></span>
   <span></span>
   <span></span>
   <span></span>
   <span></span>
   <span></span>
   <span></span>
   <span></span>
   <span></span>
   <span></span>
   <span></span>
   <span></span>
   <span></span>
   <span></span>
   <span></span>
   <span></span>
</div>
"""

non_animated_css = """
<style>
[data-testid="stSidebar"] {
    background-color: #6E8091;
    opacity: 1;
    position: fixed;
    width: 20%;
    height: 100vh;
    top: 0;
    left: 0;
    overflow: auto;
}
</style>
"""

header_css = """
<style>
[class="st-emotion-cache-1avcm0n ezrtsby2"] {
    background-color: #95B5CA;
    opacity: 1;
    position: absolute;
    width: 100%;
    height: 7vh;
    top: 0;
    left: 0;
    overflow: auto;
}
</style>
"""

st.markdown(css, unsafe_allow_html=True)
st.markdown(html, unsafe_allow_html=True)
st.markdown(non_animated_css, unsafe_allow_html=True)
st.markdown(header_css, unsafe_allow_html=True)

def page1():
    st.markdown('<h2 style="color: black; text-align: center; font-family: Georgia, serif;"><b>Real vs Satirical News Detector</b></h2>', unsafe_allow_html=True)
    st.write("\n\n\n")
    st.markdown('''<p style="color: black; text-align: justify; font-family: Georgia, serif;"><b>In this day and age where fake news spreads faster than genuine information, satirical news can be a double-edged sword.
    Providing both humour and critical perspectives, satirical news serves as both a source of entertainment and social commentary.
    However, its capability to be confused with genuine information, because of misinformation, similarity of medium and style,
    and presence of confirmation bias leading to reduced trust in media and increased discourse, highlights the importance of
    critical thinking and media literacy while drawing in with such content. The goal of this project is to distinguish
    Satirical News from Real News to combat this critical and relevant issue.</b></p>''', unsafe_allow_html=True)
    st.write("\n\n")
    st.markdown('''<p style="color: black; text-align: justify; font-family: Georgia, serif;"><b>To solve this issue, we have created an AI model using various Machine Learning algorithms like KNN and Naive Bayes
    and created a user-friendly interface to distinguish between Real and Satirical News.</b></p>''', unsafe_allow_html=True)
    st.write("\n\n")
    st.markdown('''<p style="color: black; text-align: justify; font-family: Georgia, serif;"><b>You can input either text of the article, or a screenshot of the article. It also has a choice over whether the user
    wants to upload the heading of the article, the body of the article, or the entire combined article. The model runs and gives
    output as either Satirical News or Real News.</b></p>''', unsafe_allow_html=True)

def page2():
    st.markdown('<h2 style="color: black; text-align: center; font-family: Georgia, serif;"><b>Use Text</b></h2>', unsafe_allow_html=True)
    st.markdown('<p style="color: black; text-align: justify; font-family: Georgia, serif;"><b>1. Heading of article</b></p>', unsafe_allow_html=True)
    st.markdown('<p style="color: black; text-align: justify; font-family: Georgia, serif;"><b>2. Content of article</b></p>', unsafe_allow_html=True)
    st.markdown('<p style="color: black; text-align: justify; font-family: Georgia, serif;"><b>3. Whole article</b></p>', unsafe_allow_html=True)
    st.write("\n\n")
    st.markdown('<p style="color: black; text-align: justify; font-family: Georgia, serif;"><b>Please enter option of your choice here</b></p>', unsafe_allow_html=True)
    choice = st.number_input(" ",min_value=1,max_value=3,step=1)
    st.write("\n")
    st.markdown('<p style="color: black; text-align: justify; font-family: Georgia, serif;"><b>Enter text here</b></p>', unsafe_allow_html=True)
    text = st.text_input(" ")
    st.write("\n")
    if choice==1:
        #inputData = preprocess(text)
        with open("D:/aiml/s3/project/dplEdaPdsDataset/pickle/tfidfHeading", 'rb') as file:
            tfidf_model = pickle.load(file)
        inputData = tfidf_model.transform([text])
        with open("D:/aiml/s3/project/dplEdaPdsDataset/pickle/nbHeading", 'rb') as file:
            loaded_model = pickle.load(file)
        output=loaded_model.predict(inputData)
        if output[0]==0:
            st.markdown(f'<h5 style="color: black; text-align: justify; font-family: Georgia, serif;">Result: Satirical News</h5>', unsafe_allow_html=True)
        elif output[0]==1:
            st.markdown(f'<h5 style="color: black; text-align: justify; font-family: Georgia, serif;">Result: Real News</h5>', unsafe_allow_html=True)
    elif choice==2:
        #inputData = preprocess(text)
        with open("D:/aiml/s3/project/dplEdaPdsDataset/pickle/tfidfText", 'rb') as file:
            tfidf_model = pickle.load(file)
        inputData = tfidf_model.transform([text])
        with open("D:/aiml/s3/project/dplEdaPdsDataset/pickle/nbText", 'rb') as file:
            loaded_model = pickle.load(file)
        output=loaded_model.predict(inputData)
        if output[0]==0:
            st.markdown(f'<h5 style="color: black; text-align: justify; font-family: Georgia, serif;">Result: Satirical News</h5>', unsafe_allow_html=True)
        elif output[0]==1:
            st.markdown(f'<h5 style="color: black; text-align: justify; font-family: Georgia, serif;">Result: Real News</h5>', unsafe_allow_html=True)
    else:
        #inputData = preprocess(text)
        with open("D:/aiml/s3/project/dplEdaPdsDataset/pickle/tfidfCombined", 'rb') as file:
            tfidf_model = pickle.load(file)
        inputData = tfidf_model.transform([text])
        with open("D:/aiml/s3/project/dplEdaPdsDataset/pickle/knnCombined", 'rb') as file:
            loaded_model = pickle.load(file)
        output=loaded_model.predict(inputData)
        if output[0]==0:
            st.markdown(f'<h5 style="color: black; text-align: justify; font-family: Georgia, serif;">Result: Satirical News</h5>', unsafe_allow_html=True)
        elif output[0]==1:
            st.markdown(f'<h5 style="color: black; text-align: justify; font-family: Georgia, serif;">Result: Real News</h5>', unsafe_allow_html=True)

def page3():
    st.markdown('<h2 style="color: black; text-align: center; font-family: Georgia, serif;"><b>Use Image</b></h2>', unsafe_allow_html=True)
    st.markdown('<p style="color: black; text-align: justify; font-family: Georgia, serif;"><b>1. Heading of article</b></p>', unsafe_allow_html=True)
    st.markdown('<p style="color: black; text-align: justify; font-family: Georgia, serif;"><b>2. Content of article</b></p>', unsafe_allow_html=True)
    st.markdown('<p style="color: black; text-align: justify; font-family: Georgia, serif;"><b>3. Whole article</b></p>', unsafe_allow_html=True)
    st.write("\n")
    st.markdown('<p style="color: black; text-align: justify; font-family: Georgia, serif;"><b>Please enter option of your choice here</b></p>', unsafe_allow_html=True)
    choice = st.number_input(" ",min_value=1,max_value=3,step=1)
    st.write("\n")
    st.markdown('<p style="color: black; text-align: justify; font-family: Georgia, serif;"><b>Please upload an image in .jpg, .jpeg or .png format</b></p>', unsafe_allow_html=True)
    uploaded_file = st.file_uploader(" ", type=["jpg", "jpeg", "png"])
    st.write("\n")
    if uploaded_file is not None:
        st.markdown('<p style="color: black; text-align: justify; font-family: Georgia, serif;"><b>Uploaded Image:</b></p>', unsafe_allow_html=True)
        st.image(uploaded_file, width=200)
        upload_dir = "uploads"
        if not os.path.exists(upload_dir):
            os.makedirs(upload_dir)
        file_path = os.path.join(upload_dir, uploaded_file.name)
        with open(file_path, "wb") as f:
            f.write(uploaded_file.getbuffer())
        image_path = os.path.join("uploads", uploaded_file.name)
        image = cv2.imread(file_path)
        textFromImage = pt.image_to_string(image)
        textFromImage = str(textFromImage)
        if choice==1:
            st.markdown(f'<p style="color: black; text-align: justify; font-family: Georgia, serif;"><b>Text extracted from image: <h6 style="color: black; text-align: justify; font-family: Georgia, serif;">{textFromImage}</h6></b></p>', unsafe_allow_html=True)
            with open("D:/aiml/s3/project/dplEdaPdsDataset/pickle/tfidfHeading", 'rb') as file:
                tfidf_model = pickle.load(file)
            inputData = tfidf_model.transform([textFromImage])
            with open("D:/aiml/s3/project/dplEdaPdsDataset/pickle/nbHeading", 'rb') as file:
                loaded_model = pickle.load(file)
            output=loaded_model.predict(inputData)
            if output[0]==0:
                st.markdown(f'<h5 style="color: black; text-align: justify; font-family: Georgia, serif;">Result: Satirical News</h5>', unsafe_allow_html=True)
            elif output[0]==1:
                st.markdown(f'<h5 style="color: black; text-align: justify; font-family: Georgia, serif;">Result: Real News</h5>', unsafe_allow_html=True)
        elif choice==2:
            st.markdown(f'<p style="color: black; text-align: justify; font-family: Georgia, serif;"><b>Text extracted from image: <h6 style="color: black; text-align: justify; font-family: Georgia, serif;">{textFromImage}</h6></b></p>', unsafe_allow_html=True)
            with open("D:/aiml/s3/project/dplEdaPdsDataset/pickle/tfidfText", 'rb') as file:
                tfidf_model = pickle.load(file)
            inputData = tfidf_model.transform([textFromImage])
            with open("D:/aiml/s3/project/dplEdaPdsDataset/pickle/nbText", 'rb') as file:
                loaded_model = pickle.load(file)
            output=loaded_model.predict(inputData)
            if output[0]==0:
                st.markdown(f'<h5 style="color: black; text-align: justify; font-family: Georgia, serif;">Result: Satirical News</h5>', unsafe_allow_html=True)
            elif output[0]==1:
                st.markdown(f'<h5 style="color: black; text-align: justify; font-family: Georgia, serif;">Result: Real News</h5>', unsafe_allow_html=True)
        else:
            st.markdown(f'<p style="color: black; text-align: justify; font-family: Georgia, serif;"><b>Text extracted from image: <h6 style="color: black; text-align: justify; font-family: Georgia, serif;">{textFromImage}</h6></b></p>', unsafe_allow_html=True)
            with open("D:/aiml/s3/project/dplEdaPdsDataset/pickle/tfidfCombined", 'rb') as file:
                tfidf_model = pickle.load(file)
            inputData = tfidf_model.transform([textFromImage])
            with open("D:/aiml/s3/project/dplEdaPdsDataset/pickle/knnCombined", 'rb') as file:
                loaded_model = pickle.load(file)
            output=loaded_model.predict(inputData)
            if output[0]==0:
                st.markdown(f'<h5 style="color: black; text-align: justify; font-family: Georgia, serif;">Result: Satirical News</h5>', unsafe_allow_html=True)
            elif output[0]==1:
                st.markdown(f'<h5 style="color: black; text-align: justify; font-family: Georgia, serif;">Result: Real News</h5>', unsafe_allow_html=True)

PAGES = {"About Us...": page1, "Use Text": page2, "Use Image": page3}
menu_selection = st.sidebar.selectbox('Go to', list(PAGES.keys()))
page = PAGES[menu_selection]
page()